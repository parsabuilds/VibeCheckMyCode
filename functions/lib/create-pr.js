"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPr = void 0;
const https_1 = require("firebase-functions/v2/https");
const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};
exports.createPr = (0, https_1.onRequest)({ cors: true }, async (req, res) => {
    var _a;
    if (req.method === 'OPTIONS') {
        res.set(corsHeaders);
        res.status(200).send();
        return;
    }
    res.set(corsHeaders);
    try {
        if (req.method !== 'POST') {
            res.status(405).json({ error: 'Method not allowed' });
            return;
        }
        const { githubToken, repoOwner, repoName, issue, fix } = req.body;
        if (!githubToken || !repoOwner || !repoName || !issue || !fix) {
            res.status(400).json({ error: 'Missing required fields' });
            return;
        }
        const githubApi = 'https://api.github.com';
        const authHeaders = {
            'Authorization': `Bearer ${githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
        };
        const repoResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}`, {
            headers: authHeaders,
        });
        if (!repoResponse.ok) {
            throw new Error(`Failed to fetch repository: ${repoResponse.statusText}`);
        }
        const repoData = await repoResponse.json();
        const defaultBranch = repoData.default_branch;
        const refResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}/git/refs/heads/${defaultBranch}`, { headers: authHeaders });
        if (!refResponse.ok) {
            throw new Error(`Failed to fetch branch reference: ${refResponse.statusText}`);
        }
        const refData = await refResponse.json();
        const baseSha = refData.object.sha;
        const branchName = `fix/security-${issue.severity}-${issue.id.substring(0, 8)}`;
        const createBranchResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}/git/refs`, {
            method: 'POST',
            headers: authHeaders,
            body: JSON.stringify({
                ref: `refs/heads/${branchName}`,
                sha: baseSha,
            }),
        });
        if (!createBranchResponse.ok) {
            const errorData = await createBranchResponse.json();
            if ((_a = errorData.message) === null || _a === void 0 ? void 0 : _a.includes('already exists')) {
                res.status(409).json({ error: 'A branch for this fix already exists' });
                return;
            }
            throw new Error(`Failed to create branch: ${createBranchResponse.statusText}`);
        }
        const fileResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}/contents/${fix.file_path}?ref=${defaultBranch}`, { headers: authHeaders });
        if (!fileResponse.ok) {
            throw new Error(`Failed to fetch file: ${fileResponse.statusText}`);
        }
        const fileData = await fileResponse.json();
        const fileSha = fileData.sha;
        const updateFileResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}/contents/${fix.file_path}`, {
            method: 'PUT',
            headers: authHeaders,
            body: JSON.stringify({
                message: `Fix ${issue.severity} security issue: ${issue.title}`,
                content: Buffer.from(fix.fixed_content).toString('base64'),
                branch: branchName,
                sha: fileSha,
            }),
        });
        if (!updateFileResponse.ok) {
            throw new Error(`Failed to update file: ${updateFileResponse.statusText}`);
        }
        const prTitle = `[Security] Fix ${issue.severity} issue: ${issue.title}`;
        const prBody = `## Security Fix

**Severity:** ${issue.severity.toUpperCase()}
**Category:** ${issue.category}

### Issue Description
${issue.description}

### What Changed
${fix.explanation}

### Files Modified
- \`${fix.file_path}\`

---

ðŸ”’ This PR was automatically generated by SecureAF to fix a security vulnerability.

**Please review carefully before merging!**`;
        const createPRResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}/pulls`, {
            method: 'POST',
            headers: authHeaders,
            body: JSON.stringify({
                title: prTitle,
                body: prBody,
                head: branchName,
                base: defaultBranch,
            }),
        });
        if (!createPRResponse.ok) {
            const errorData = await createPRResponse.json();
            throw new Error(`Failed to create PR: ${errorData.message || createPRResponse.statusText}`);
        }
        const prData = await createPRResponse.json();
        res.json({
            success: true,
            pr: {
                url: prData.html_url,
                number: prData.number,
                branch: branchName,
                title: prData.title,
            },
        });
    }
    catch (error) {
        console.error('PR creation error:', error);
        res.status(500).json({
            error: error.message || 'Failed to create pull request',
        });
    }
});
//# sourceMappingURL=create-pr.js.map