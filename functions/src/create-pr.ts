import { onRequest } from 'firebase-functions/v2/https';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

interface CreatePRRequest {
  githubToken: string;
  repoOwner: string;
  repoName: string;
  issue: {
    id: string;
    severity: string;
    category: string;
    title: string;
    description: string;
    filePath?: string;
  };
  fix: {
    file_path: string;
    fixed_content: string;
    explanation: string;
  };
}

export const createPr = onRequest({ cors: true }, async (req, res) => {
  if (req.method === 'OPTIONS') {
    res.set(corsHeaders);
    res.status(200).send();
    return;
  }

  res.set(corsHeaders);

  try {
    if (req.method !== 'POST') {
      res.status(405).json({ error: 'Method not allowed' });
      return;
    }

    const { githubToken, repoOwner, repoName, issue, fix } = req.body as CreatePRRequest;

    if (!githubToken || !repoOwner || !repoName || !issue || !fix) {
      res.status(400).json({ error: 'Missing required fields' });
      return;
    }

    const githubApi = 'https://api.github.com';
    const authHeaders = {
      'Authorization': `Bearer ${githubToken}`,
      'Accept': 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
    };

    const repoResponse = await fetch(`${githubApi}/repos/${repoOwner}/${repoName}`, {
      headers: authHeaders,
    });

    if (!repoResponse.ok) {
      throw new Error(`Failed to fetch repository: ${repoResponse.statusText}`);
    }

    const repoData = await repoResponse.json();
    const defaultBranch = repoData.default_branch;

    const refResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/git/refs/heads/${defaultBranch}`,
      { headers: authHeaders }
    );

    if (!refResponse.ok) {
      throw new Error(`Failed to fetch branch reference: ${refResponse.statusText}`);
    }

    const refData = await refResponse.json();
    const baseSha = refData.object.sha;

    const branchName = `fix/security-${issue.severity}-${issue.id.substring(0, 8)}`;
    const createBranchResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/git/refs`,
      {
        method: 'POST',
        headers: authHeaders,
        body: JSON.stringify({
          ref: `refs/heads/${branchName}`,
          sha: baseSha,
        }),
      }
    );

    if (!createBranchResponse.ok) {
      const errorData = await createBranchResponse.json();
      if (errorData.message?.includes('already exists')) {
        res.status(409).json({ error: 'A branch for this fix already exists' });
        return;
      }
      throw new Error(`Failed to create branch: ${createBranchResponse.statusText}`);
    }

    const fileResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/contents/${fix.file_path}?ref=${defaultBranch}`,
      { headers: authHeaders }
    );

    if (!fileResponse.ok) {
      throw new Error(`Failed to fetch file: ${fileResponse.statusText}`);
    }

    const fileData = await fileResponse.json();
    const fileSha = fileData.sha;

    const updateFileResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/contents/${fix.file_path}`,
      {
        method: 'PUT',
        headers: authHeaders,
        body: JSON.stringify({
          message: `Fix ${issue.severity} security issue: ${issue.title}`,
          content: Buffer.from(fix.fixed_content).toString('base64'),
          branch: branchName,
          sha: fileSha,
        }),
      }
    );

    if (!updateFileResponse.ok) {
      throw new Error(`Failed to update file: ${updateFileResponse.statusText}`);
    }

    const prTitle = `[Security] Fix ${issue.severity} issue: ${issue.title}`;
    const prBody = `## Security Fix

**Severity:** ${issue.severity.toUpperCase()}
**Category:** ${issue.category}

### Issue Description
${issue.description}

### What Changed
${fix.explanation}

### Files Modified
- \`${fix.file_path}\`

---

ðŸ”’ This PR was automatically generated by SecureAF to fix a security vulnerability.

**Please review carefully before merging!**`;

    const createPRResponse = await fetch(
      `${githubApi}/repos/${repoOwner}/${repoName}/pulls`,
      {
        method: 'POST',
        headers: authHeaders,
        body: JSON.stringify({
          title: prTitle,
          body: prBody,
          head: branchName,
          base: defaultBranch,
        }),
      }
    );

    if (!createPRResponse.ok) {
      const errorData = await createPRResponse.json();
      throw new Error(`Failed to create PR: ${errorData.message || createPRResponse.statusText}`);
    }

    const prData = await createPRResponse.json();

    res.json({
      success: true,
      pr: {
        url: prData.html_url,
        number: prData.number,
        branch: branchName,
        title: prData.title,
      },
    });
  } catch (error: any) {
    console.error('PR creation error:', error);
    res.status(500).json({
      error: error.message || 'Failed to create pull request',
    });
  }
});
